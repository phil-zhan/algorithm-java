# <font color="red">**Morris遍历**</font>

### Morris遍历是什么？
```md
一种遍历二叉树的方式，并且时间复杂度O(N)，额外空间复杂度O(1)

通过利用原树中大量空闲指针的方式，达到节省空间的目的

    
```

### Morris遍历细节
```md
假设来到当前节点cur，开始时cur来到头节点位置
1）如果cur没有左孩子，cur向右移动(cur = cur.right)
2）如果cur有左孩子，找到左子树上最右的节点mostRight：
	a.如果mostRight的右指针指向空，让其指向cur，
	    然后cur向左移动(cur = cur.left)
	b.如果mostRight的右指针指向cur，让其指向null，
	    然后cur向右移动(cur = cur.right)
3）cur为空时遍历停止

```


### Morris遍历实质
```md
建立一种机制：

对于没有左子树的节点只到达一次，

对于有左子树的节点会到达两次

morris遍历时间复杂度依然是O(N)

```

### Morris序列加工为先序
```md
出现两次的节点，只是第一次打印就行，第二次出现直接忽略即可。出现一次的，直接打印
```

### Morris序列加工为中序
```md
出现两次的节点，第一次出现直接忽略，第二次出现才打印。出现一次的，直接打印
```


### Morris序列加工为后序
```md
将处理时间放在能回到自己两次的时间
处理的时候，不单单打印单个节点。而是在第二次回到某个节点的时候【左树最右指针等于自己的时候】，逆序打印其左树的右边界
遍历完成后，也就是cur为空的时候，逆序打印整棵树的右边界【不能用栈。用 Morris遍历 本身就是为了省空间。】
【采用链表反转的方式。遍历右边界，将其链表反转。将其右子节点的指针指向其本身。打印完成后，再调回来】
```


### 题目一
**【Code02】**
```md
给定一棵二叉树的头节点head

求以head为头的树中，最小深度是多少？


解决方案：可以利用二叉树的递归套路。也可以用Morris遍历来实现
```


### 二叉树的解法
1. 二叉树的递归套路【时间复杂度是 O(N) 空间复杂度是树的深度】
2. Morris遍历【时间复杂度是 O(N) 空间复杂度是O(1)】

```md
具体该怎么选择：
【需要左树的完整信息和右树的完整信息才能组合成当前数的信息。就只能用二叉树的递归套路。】【强信息整合】
【不需要左树的完整信息或右树的完整信息才能组合成当前数的信息。可以用 Morris 遍历完成。】【非强信息整合】
```
