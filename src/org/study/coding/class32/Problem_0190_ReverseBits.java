package org.study.coding.class32;

/**
 * 190. 颠倒二进制位
 * 颠倒给定的 32 位无符号整数的二进制位。
 *
 * 提示：
 *
 * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
 * 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
 *
 *
 * 示例 1：
 *
 * 输入：n = 00000010100101000001111010011100
 * 输出：964176192 (00111001011110000010100101000000)
 * 解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
 *      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
 * 示例 2：
 *
 * 输入：n = 11111111111111111111111111111101
 * 输出：3221225471 (10111111111111111111111111111111)
 * 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
 *      因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
 *
 * 题意：将num的二进制逆序一下，返回逆序后的二进制代表的数字
 *
 * 解法：
 * 1）转成字符数组。逆序之后再怼回去。【不推荐。太low】
 * 2）
 *
 * @since 2022-04-19 07:50:57
 */
public class Problem_0190_ReverseBits {


	/**
	 * 代码看着很魔幻吧？
	 * 给个例子，假设n二进制为：
	 * 1011 0111 0011 1001 0011 1111 0110 1010
	 * 解释一下，第一行，是把n左边16位，和n右边16位交换
	 * n = (n >>> 16) | (n << 16);
	 * 因为 n >>> 16 就是左边16位被移动到了右侧
	 * 同时 n << 16  就是右边16位被移动到了左侧
	 * 又 | 在了一起，所以，n变成了
	 * 0011 1111 0110 1010 1011 0111 0011 1001
	 *
	 * 第二行，
	 * n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);
	 * (n & 0xff00ff00)
	 * 这一句意思是，左侧开始算0~7位，保留；8~15位，全变0；16~23位，保留；24~31位，全变0
	 * 0011 1111 0000 0000 1011 0111 0000 0000
	 * (n & 0xff00ff00) >>> 8 这句就是上面的值，统一向右移动8位，变成：
	 * 0000 0000 0011 1111 0000 0000 1011 0111
	 * 	//
	 * 	//
	 * (n & 0x00ff00ff)
	 * 这一句意思是，左侧开始算0~7位，全变0；8~15位，保留；16~23位，全变0；24~31位，保留
	 * 0000 0000 0110 1010 0000 0000 0011 1001
	 * (n & 0x00ff00ff) << 8 这句就是上面的值，统一向左移动8位，变成：
	 * 0110 1010 0000 0000 0011 1001 0000 0000
	 * 那么 ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8)
	 * 什么效果？就是n的0~7位和8~15位交换了，16~23位和24~31位交换了
	 * 0110 1010 0011 1111 0011 1001 1011 0111
	 *
	 * 也就是说，整个过程是n的左16位，和右16位交换
	 * n的左16位的内部，左8位和右8位交换；n的右16位的内部，左8位和右8位交换
	 * 接下来的一行，其实是，从左边开始算，0~7位内部，左4和右4交换；8~15位，左4和右4交换；...
	 * 接下来的一行，其实是，从左边开始算，0~3位内部，左2和右2交换；4~7位，左2和右2交换；...
	 * 最后的一行，其实是，从左边开始算，0~1位内部，左1和右1交换；2~3位，左1和右1交换；...
	 *
	 *
	 * @since 2022-04-19 07:52:28
	 */
	public static int reverseBits(int n) {
		// 大体思路是
		// 高 16 位和低 16 为交换
		// 在每个16位中，高 8 位和低 8 为交换
		// 在每个8位中，高 4 位和低 4 为交换
		// 在每个4位中，高 2 位和低 2 为交换
		// 在每个2位中，高 1 位和低 1 为交换


		// n的高16位，和n的低16位，交换 【 “>>>” : 不带符号移动】
		n = (n >>> 16) | (n << 16);

		// ff00ff00 : f是15的意思。二进制就表示为 1111 。ff00就表示 1111 1111  0000 0000
		// 0x开头考试16进制
		// n & 0xff00ff00 :表示将 n 的32个位分成4块，每块8位。与完之后，第一块和第三块的1保留，第二块和第四快的全变成0.再右移8位。就等于是让第一块和第三块，移动到第二块和第四块的位置
		// n & 0x00ff00ff :表示将 n 的32个位分成4块，每块8位。与完之后，第二块和第四块的1保留，第一块和第三快的全变成0.再左移8位。就等于是让第四块和第二块，移动到第三块和第二块的位置
		// 最后再求一个或逻辑。就是将第一块和第二块交换，第三块和第四块交换
		n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);
		n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);

		// c的二进制是 1100
		// 3的二进制是 0011
		n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);

		// a的二进制是 1010
		// 5的二进制是 0101
		n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);
		return n;
	}

}
