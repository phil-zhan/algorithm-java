# 大厂高频算法和数据结构面试题3

### 最长无重复字符子串长度
1. 求一个字符串中，最长无重复字符子串长度
   * 解法：
   * 考虑以每个位置结尾的情况，前面能推多久能不重复
   * 1)在从左往右的过程中，记录每个字符最后一次出现的位置。用于帮助后面的加速
   * 2)记录前一个字符能往左推的最大距离。当前位置能推的最大距离，不能超过前一个字符能推的最大距离
   * 考虑这两个因素能推出来的最大距离，取最小值就OK  

2. 只由小写字母（a~z）组成的一批字符串，都放在字符类型的数组String[] arr中，如果其中某两个字符串所含有的字符种类完全一样  
   就将两个字符串算作一类，比如baacbba和bac就算作一类，返回arr中有多少类
   * 解法：  
   * 考虑用 int 类型的数来表示一个分类【每个位表示该位置对应的字母是否出现过】
   * 同样的字母组合，弄出来的数肯定是一样的，再将所有的数都放贷set集合里面取
   * 最后统计set集合的数量

3. 给定一个只有0和1组成的二维数组，返回边框全是1（内部无所谓）的最大正方形面积
   * https://leetcode.com/problems/largest-1-bordered-square/
   * 解法：
   * 枚举所有的正方形【任意的一个点加一个边长，就能组成一个正方形】
   * 矩形范围内，枚举所有的点是 O(N^2)
   * 枚举所有的边长是 O(N)
   * 所有枚举所有的正方形是 O(N^3)
   * 对应每一个正方形，考察其边长上是否都是1
   * 做出一个辅助结构
   * 先算出从每个位置`i` 开始，
   * 往右延长（包含自己），最多能有多少个 1，
   * 往下延长（包含自己），最多能有多少个 1
   * 
   * 当枚举到某个正方形时，考察以其左上角点（往有、往下），左下角（往右），右上角（往下），对应的点，在对应的方向上，最多能延展的1是否够边长的长度
   * 若够，该正方形成立，反之则不成立
   * 注意，枚举边时，其往右和往下的最大延伸长度只能取二者的最小值。【因为是正方形】

   

4. 给定一个数组arr，代表每个人的能力值。再给定一个非负数k，如果两个人能力差值正好为k，那么可以凑在一起比赛  
   一局比赛只有两个人，返回最多可以同时有多少场比赛
   * 解法：
   * 先排序
   * 然后准备一个窗口，从左往右滑动
   * arr[R]-arr[L]<k  R++
   * arr[R]-arr[L]>k  L++
   * arr[R]-arr[L]=k  ans++
   * L >= R   R++  【维持窗口。等于R的时候，窗口只有一个数。大于R是整个窗口都消失了。本题不会出现L>R的情况。】
   * 
   * 用过了的数字，记得打标记，不要重复使用。不管是L和R，
   * 本题是贪心
   * 优先满足小的值匹配【窗口从左往右滑】。不会错过最懂匹配常数的情况


5. 给定一个正数数组arr，代表若干人的体重，再给定一个正数limit，表示所有船共同拥有的载重量，每艘船最多坐两人，且不能超过载重  
   想让所有的人同时过河，并且用最好的分配方法让船尽量少，返回最少的船数  
   Leetcode链接 : https://leetcode.com/problems/boats-to-save-people/
   * 解法1：
   * 先排序
   * 设置两个指针 L 和 R
   * L指向小于等于 arr[limit/2]的最后一个数
   * R指向大于等于 arr[limit/2]的第一个一个数
   * 考察 L和R能否凑一船
   * 不可以：L指针左移
   * 可以：考察R指针，R指针右移，找到不能和当前L组成一船的位置的前一个位置（也就是找到能和当前L位置组成一船的最后一个位置）
   * 此时，R滑动的长度假设为L个数。要消化掉这L个数。用从此时的L开始，往左推L个数是最省的【L往右，搞不定这L个数。若果往左太多，又会浪费】【见图】
   * 这样，就可以一次性搞定L个。达到加速的目的
   * 【匹配过程中，将匹配走的都做个标记】
   * 若果右边先耗尽。【剩下没有被匹配走的都是左边的，那么剩下的数除以二就是额外需要的船数】【在对称轴以左，肯定不会超载】
   * 若左侧先耗尽。【剩下没有被匹配走的（有左边没有被标记的，也有右边没有被匹配的）】
   * 【在右边的，每个人就是一个船，在左边没有被标记的，除以二，向上取整就是需要的船数】【在对称轴以右，任何两个肯定都会超载】
   * 
   * 解法2：
   * 利用首尾指针解题


6. 给定整数数组nums和目标值goal，需要从nums中选出一个子序列，使子序列元素总和最接近goal  
   也就是说如果子序列元素和为sum ，需要最小化绝对差abs(sum - goal)，返回 abs(sum - goal)可能的最小值  
   注意数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。
   * 本题测试链接 : https://leetcode.com/problems/closest-subsequence-sum/
   * 本题数据量描述:
   * 1 <= nums.length <= 40
   * -10^7 <= nums[i] <= 10^7
   * -10^9 <= goal <= 10^9
   * 通过这个数据量描述可知，需要用到分治，因为数组长度不大
   * 而值很大，用动态规划的话，表会爆

7. 电子游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门  
   给定一个字符串ring，表示刻在外环上的编码；给定另一个字符串key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数  
   最初，ring的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使key的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完key中的所有字符  
   旋转ring拼出 key 字符key[i]的阶段中：  
   您可以将ring顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串ring的一个字符与 12:00 方向对齐，并且这个字符必须等于字符key[i] 。  
   如果字符key[i]已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作1 步。按完之后，您可以开始拼写key的下一个字符（下一阶段）, 直至完成所有拼写。  
   * Leetcode题目：https://leetcode.com/problems/freedom-trail/
   * 生成一张表
   * Map<String,List<String>>
   * a:存在的位置有哪些
   * b:存在的位置有哪些
   * c:存在的位置有哪些
   * ...
   * 
   * 遍历目标串，来到某个字符，找到该字符存在的位置，让所有位置都去转一下，最后抓一个最优的

8. 给定三个参数，二叉树的头节点head，树上某个节点target，正数K。从target开始，可以向上走或者向下走，返回与target的距离是K的所有节点  
   * 准备一个parentMap，让所有节点都能找到其父节点
   * 从 target 开始，宽度优先遍历【遍历其父、左、右】。第K层的节点就是要找的节点
   * 注意去掉已经访问过的节点
