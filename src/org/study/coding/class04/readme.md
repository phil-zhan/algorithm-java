# 大厂高频算法和数据结构面试题4

### 

1. 数组为{3, 2, 2, 3, 1}，查询为(0, 3, 2)，意思是在数组里下标0~3这个范围上，有几个？答案返回2
   假设给你一个数组arr，对这个数组的查询非常频繁，且都给了查询组，请返回所有查询的结果
   * 解法：
   * 设计结构为Map<Integer,List<Integer>>
   * key:是数组中的某个数
   * value：是该数在数组中出现的位置的集合【有序集合】
   * 查询时。根据某个数，找到其出现的所有位置，看有几个落在所给的目标范围。采用两次二分法【大于等于最小边界】【小于等于最大边界】

2. 返回一个数组中子数组最大累加和
   * 解法：
   * 考虑以 index 位置结尾，最多能往左推多远
   * index位置，有两种选择
   * 要么往左推	（当前位置的数，加上 前面一个数结尾的子数组的最大累加和）
   * 要么不往左推
   * 两种情况抓一个最大值

3. 返回一个二维数组中子矩阵最大累加和
   * 解法：
   * 每次都考虑 i行到j行的最大值
   * i行到i行
   * i行到i+1行
   * i行到i+2行
   * i行到i+3行
   * 。。。。
   * 只有一行时，直接按照单个数组球最大累加和方法来求
   * 多行时，求用从上到下累加的方式弄出一个一维数组。再按照一维数组求最大累加和的方式来做

4. 返回一个数组中所选数字不能相邻的情况下最大子序列累加和
   * 解法：
   * 考虑 [0...i]范围上，不能相邻的情况下，最大累加和
   *
   * 1）不要当前位置的数，直接去前一个位置的答案
   * 2）要当前位置的数，往前推两位去取答案【也就是不要去前一位的答案】
   * 3）要当前位置的数，且只要当前位置的数
   *
   * 空间压缩，有限个变量向后滚

5. 老师想给孩子们分发糖果，有N个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分  
   你需要按照以下要求，帮助老师给这些孩子分发糖果：  
   每个孩子至少分配到 1 个糖果。  
   评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。【不考虑等于的情况】  
   只和他相邻的位置比  
   那么这样下来，返回老师至少需要准备多少颗糖果  
   进阶：在原来要求的基础上，增加一个要求，相邻的孩子间如果分数一样，分的糖果数必须一样，返回至少需要准备多少颗糖果  
   * Leetcode题目：https://leetcode.com/problems/candy/
   * 解法：
   * 这是原问题的优良解
   * 时间复杂度O(N)，额外空间复杂度O(N)
   * 贪心 + 预处理结构
   *
   * 准备一个left数组。代表左边的坡度。【left[i],表示从左往右的情况下，i 号孩子最少需要多少糖】
   * 从左往右，当前位置比左边的分数高，就+1个糖，不再比左边的大，就减1. 最低为1
   *
   * 准备一个 right 数组. 代表右边的坡度【right[i],表示从右往左的情况下，i 号孩子最少需要多少糖】
   * 从右往左，当前位置比右边的分数高，就+1个糖，不再比右边的大，就减1. 最低为1
   *
   * 每个孩子的分糖数量，就是 Math.max(left[i],right[i])
   * 因为左边和右边以较大坡为准。因为每个孩子要同时满足左右两边
   *
   * 进阶：在原来要求的基础上，增加一个要求，相邻的孩子间如果分数一样，分的糖果数必须一样，返回至少需要准备多少颗糖果
   * 在原来的左右数组的基础上
   * 重新设计左右数组
   *
   * 左数组
   * 1）当前位置的分数比左边位置的高，就加1
   * 2）当前位置的分数和左边位置的一样高，就继承
   * 3）当前位置的分数比左边位置的一样低，就归1
   *
   * 右数组也类似
   * 1）当前位置的分数比右边位置的高，就加1
   * 2）当前位置的分数和右边位置的一样高，就继承
   * 3）当前位置的分数比右边位置的一样低，就归1
   *
   * 每个位置还是取左右两种情况下的最大值

6. 生成长度为size的达标数组，什么叫达标？对于任意的i<k<j，满足[i]+[j]!=[k]*2。给定一个正数size，返回长度为size的达标数组
   * 解法：
   * 生成长度为size的达标数组
   * 达标：对于任意的 i<k<j，满足 [i] + [j] != [k] * 2
   * 如果 a、b、c 达标。即 a+c != 2b
   * 那么 2a、2b、2c  也达标
   * 2a+1、2b+1、2c+1 也达标
   *
   * 由此可以得出
   * [2a、2b、2c,2a+1、2b+1、2c+1]  也达标
   * 如果只在左半部分选，达标
   * 如果只在右半部分选，达标
   * 如果选中的是左边一个，右边一个。那么肯定也达标。因为一个偶数加一个奇数，肯定是奇数，不可能是谁的2倍
   *
   *
   * 要生成长度为 n 的
   * 只需要一个长度为 n/2 【向上取整。到时候翻倍。如果是奇数，就扔掉一个好了】
   *
   * 如 n = 7
   * 需要长度为7的，准备长度为 4 的
   * 需要长度为4的，准备长度为 2 的
   * 需要长度为2的，准备长度为 1 的
   * [1]
   * [2,3]
   * [4,6,5,7]
   * [8,12,10,14,9,13,11,15]
   *
   * 长度为1 的时候，写啥都行，往后就是=翻倍和翻倍加1

7. 给定三个字符串s1、s2、s3，请你帮忙验证s3是否是由s1和s2交错组成的  
   s1在s3中的相对次序不变  
   s2在s3中的相对次序也不变  
   s3仅仅由s1和s2组成  
   s的长度等于s1的长度加s2的长度  
   Leetcode题目：https://leetcode.com/problems/interleaving-string/  
   * 解法：
   * 动态规划【样本对应】
   * s1只拿前 i 个字符
   * s2只拿前 j 个字符
   * 能否交错组成s3的前（i + j）
   * 
   * 如果s3 的最后一个字符来自 s1.那么s1的前面 i-1 个字符和 s2 的j个字符就要能组成s3的前面 i+j-1
   * 如果s3 的最后一个字符来自 s2.那么s2的前面 j-1 个字符和 s1 的i个字符就要能组成s3的前面 i+j-1
   * 两种情况取 或  。就是任意一个位置的情况。
   * 
   * 样本对应模型【体现在二维表上，就是一个样本是行，另外一个样本是列】
   * 也就是两个样本都可变


8. 大楼轮廓线问题
   Leetcode题目：https://leetcode.com/problems/the-skyline-problem/
   * 解法：
   * 沿着x轴的正方向，从走往右。最大高度发生变化的时候，就记录一下当前轮廓线的起点和高度，
   * 在下一次高度发生变化（增加或减少）的时候，补全当前轮廓线的结束点，同时记录下一次的起点和高度
   * 最后一次变为0的时候，补全上一次的结束点就行。
   * 
   * 最大高度怎么追踪？？
   * 原始数据是[x1,x2,h] 表示一栋大楼，x1开始到x2结束，高度为h。
   * 将其封装为两个对象。
   * 对象1：x1位置，增加了h
   * 对象2：x2位置，减少了h
   * 对于一栋楼来说，只会在这两个点，发生高度的变化。收集答案的时候，只需要考虑这些可能导致最大高度发生变化的点。
   * 设最开始的高度为0，高度发生变化，就收集答案
   * 
   * 这样就将所有的楼封装成了 2N 个对象
   * 将这些对象按照第一维度排序（也就是x的坐标位置）。如果x的值是一样的，加的放在减的前面，
   * 防止纸片大楼，也就是一个大楼的起点和终点的值是一样的。避免先减后加，导致map出错
   * 
   * 然后从小到大考察这些对象，就等于是沿着x轴的方向考察可能发生变化的点
   * 
   * 考察：
   * 准备一个TreeMap有序表
   * key: 高度
   * value: 该高度加入的次数【value设计成次数，每一次高度减少，代表一栋大楼的结束，应该移除这栋大楼，为了防止多个大楼等高，只能移除一次】
   * 
   * 在每个对象来的时候，先将该对象对应的高度加入map（如果是增加高度，就将对应的key加1，如果是减少，就将对应的高度减1.)
   * 增加的时候，如果不存在，value就是1，减少的时候，如果减成0，就将该key高度从map中移除
   * 【代表该高度考察完成了，后面不会有该高度。不要影响后面的高度取最大值】
   * 加完只后，get一下map，拿到最大高度【有序表拿最大值LogN】，看高度相对于之前的最大高度，是否有变化。


