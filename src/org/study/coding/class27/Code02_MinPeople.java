package org.study.coding.class27;

import java.util.Arrays;

public class Code02_MinPeople {

//  三道题如下：
//	微信面试题
//	题目一：
//	股民小 A 有一天穿越回到了 n 天前，他能记住某只股票连续 n 天的价格；他手上有足够多的启动资金，他可以在这 n 天内多次交易，但是有个限制
//	如果已经购买了一个股票，在卖出它之前就不能再继续购买股票了。
//	到 n 天之后，小 A 不能再持有股票。
//	求问 这 n 天内，小 A 能够获得的利润的最大值
//	如果不需要手续费的话，求最大的利润
//	function(number) {
//	return number
//	}
//	输入: prices = [3, 1, 2, 8, 5, 9]
//	输出: 11
//
//	题目二：
//	企鹅厂每年都会发文化衫，文化衫有很多种，厂庆的时候，企鹅们都需要穿文化衫来拍照
//  一次采访中，记者随机遇到的企鹅，企鹅会告诉记者还有多少企鹅跟他穿一种文化衫
//  我们将这些回答放在 answers 数组里，返回鹅厂中企鹅的最少数量。
//	输入: answers = [1]    输出：2
//	输入: answers = [1, 1, 2]    输出：5
//  Leetcode题目：https://leetcode.com/problems/rabbits-in-forest/
//
//	题目三：
//	WXG 的秘书有一堆的文件袋，现在秘书需要把文件袋嵌套收纳起来。请你帮他计算下，最大嵌套数量。
//	给你一个二维整数数组 folders ，其中 folders[i] = [wi, hi] ，表示第 i 个文件袋的宽度和长度
//	当某一个文件袋的宽度和长度都比这个另外一个文件袋大的时候，前者就能把后者装起来，称之为一组文件袋。
//	请计算，最大的一组文件袋的数量是多少。
//	实例
//	输入：[[6,10],[11,14],[6,1],[16,14],[13,2]]
//	输出： 3

    /**
     * 题目一，股票系列专题，大厂刷题班15节
     * 题目三，最长递增子序列专题，大厂刷题班第9节
     * 我们来讲一下题目二
     * <p>
     * 题意：
     * 问卷可能会不全
     * 但是每个人说的话都是正确的
     * 返回最少的人数
     * <p>
     * 解法：
     * 先对数组排序，让说的一样的人在一起。假设排序后[1,1,1,1,2,2,3,3,3,3,3,3,3,3,4,4,4,5,5,5,5,5,5,5,5,5]
     * 我们要的是最少人数
     * 如果数组能内部消化，那么肯定是最少
     * 比如这里的前面4个1就可以两两消化，那么现在就是4个人
     * 两个2，这里表示的是除了自己以外还有两个人。如果是三个2的话，刚好可以自己消化，
     * 这里只有两个，说明问卷没收全。这里最少就是3个人，也就是这两个2分在一组，但是差一个人，得给补上
     * 数字3，需要4个人一组，每组4人，刚好8人
     * 数字4，需要5人一组，这里只有三个4，需要补两个
     * 数字5需要6个人一组，这里9个5，需要分成两组。12个人。第二组就需要补3个了
     * <p>
     * ============================ 抽象化 ================================
     * 如果当前的数字是x，有 num个。
     * 那么需要 x+1 人分成一组。
     * 需要分成 y=num/(x+1) 向上取整。【a/b 向上取整，也就是 (a+(b-1))/b 】 【 (num+x)/(x+1) 】
     * 当前这个数字对应的最少人数 就是 y*(x+1)
     * 带入就是 [(num+x)/(x+1) ] * (x+1) 人 【这里不能约，是需要算前面的】
     *
     * @since 2022-04-11 07:20:48
     */
    public static int numRabbits(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        Arrays.sort(arr);
        int x = arr[0];
        int num = 1;
        int ans = 0;
        for (int i = 1; i < arr.length; i++) {

            //之前的x就需要结算了
            if (x != arr[i]) {

                // 这里不要约掉，约掉可能就错了
                ans += ((num + x) / (x + 1)) * (x + 1);
                x = arr[i];
                num = 1;
            } else {
                // 当前组的数量加加
                num++;
            }
        }

        // 不要忘记结算最后一组
        return ans + ((num + x) / (x + 1)) * (x + 1);
    }

}
