# 大厂高频算法和数据结构面试题3

### 

1. 已知一棵搜索二叉树上没有重复值的节点，现在有一个数组arr，  
   是这棵搜索二叉树先序遍历的结果，请根据arr生成整棵树并返回头节点  
   * 解法：
   * 搜索二叉树
   * 无重复，恢复出来的树肯定是唯一的
   * 有重复，不一定对应唯一的树
   <br/>
2. 如果一个节点X，它左树结构和右树结构完全一样，
   那么我们说以X为头的树是相等树，
   给定一棵二叉树的头节点head，返回head整棵树上有多少棵相等子树
   * 解法：
   * 设计一个hash，得和左、右树及当前的值 都相关
   * 因为比较两个树是不是相等，要比较每个几点的值和结构
   * 这里采用先序序列化来实现【注意，空树也要有对应字符】
   * 先序来表示一个树的结构，没有任何歧义。
   * 将其取hash值
   * hash，相同的输入，必定导致相同的输出
   * 任何长度的输入，其输出的长度必定一样
   * 每次都比较相同长度的字符串。就能实现 O(1)
   <br/>
3. 编辑距离问题  
   要从 字符串s1 变换成 字符串s2  
   增加一个字符的成本是 ic  
   删除一个字符的成本是 dc  
   替换一个字符的成本是 rc  
   请返回最小的变换（编辑）成本  
   编辑距离可以描述两个字符串的相似程度，在工程上，用在搜索领域的模糊搜索等。  
   * 解法：
   * 本题利用样本对应模型。	 
   * str1做行，str2做列
   * dp[i][j] : 表示str1前缀i个字符，str2前缀取 j个字符。从str1编辑成str2的编辑距离是多少
   * 从空串编辑到空，成本是0
   * dp[0][0] = 0
   * 
   * 第一列。str2 是空。要从str1变成str2，只能删除
   * 第一行。str1是空，要变成str2，只能添加
   * 普遍位置
   * 1) str1的当前 i 位置是多余的，让str1的前面去搞定str2。删除str1的i字符
   * 2) str1的当前 整体先变成str2的前面除j位置的所有字符，然后再在str2上增加一个 j 字符
   * 3) 如果str1[i] == str2[j] 那么str1的前面i-1个字符去搞定str2的j-1个字符就行
   * 4) 如果str1[i] != str2[j] 那么str1的前面i-1个字符去搞定str2的j-1个字符就行,最后一个字符替换
   * 不再有其他的可能  
   <br/>
4. 给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？
   比如 s1 = "abcde"，s2 = "axbc"，s2删掉'x'即可，返回1
   * 解法一
   * 求出str2所有的子序列【每个位置要或不要 2^N】，然后按照长度排序，长度大的排在前面。
   * 然后考察哪个子序列字符串和s1的某个子串相等(KMP)，答案就出来了。
   * 分析：
   * 因为题目原本的样本数据中，有特别说明s2的长度很小。所以这么做也没有太大问题，也几乎不会超时。
   * 但是如果某一次考试给定的s2长度远大于s1，这么做就不合适了。
   * O(2^M * N)  【M不大的话，这个就是最优解】
   * 
   * 解法二
   * 生成所有s1的子串
   * 然后考察每个子串和s2的编辑距离(假设编辑距离只有删除动作且删除一个字符的代价为1)
   * 每一个子串，都去考虑，将s2编辑成该子串的最小编辑距离。最后抓一个最小的
   * 如果s1的长度较小，s2长度较大，这个方法比较合适



