# <font color="red">**对数器找规律**</font>

### 对数器找规律  
1. 某个面试题，输入参数类型简单，并且只有一个实际参数  
2. 要求的返回值类型也简单，并且只有一个  
3. 用暴力方法，把输入参数对应的返回值，打印出来看看，进而优化code  


### 题目一
小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量。  
1. 能装下6个苹果的袋子  
2. 能装下8个苹果的袋子  
小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，且使用的每个袋子必须装满。  
给定一个正整数N，返回至少使用多少袋子。如果N无法让使用的每个袋子必须装满，返回-1  


### 题目二
给定一个正整数N，表示有N份青草统一堆放在仓库里  
有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草  
不管是牛还是羊，每一轮能吃的草量必须是：  
1，4，16，64…(4的某次方)  
谁最先把草吃完，谁获胜  
假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定  
根据唯一的参数N，返回谁会赢  


### 题目三
定义一种数：可以表示成若干（数量>1）连续正数和的数  
比如:  
5 = 2+3，5就是这样的数  
12 = 3+4+5，12就是这样的数  
1不是这样的数，因为要求数量大于1个、连续正数和  
2 = 1 + 1，2也不是，因为等号右边不是连续正数  
给定一个参数N，返回是不是可以表示成若干连续正数和的数[true、false]  


### 根据数据规模猜解法
1. C/C++，1秒处理的指令条数为10的8次方  
2. Java等语言，1~4秒处理的指令条数为10的8次方  
3. 这里就有大量的空间了！  
**根据数据量推解法。10^6以上，就不要考虑log(N^2)以上的时间复杂度了**  

### 题目四
int[] d，d[i]：i号怪兽的能力  
int[] p，p[i]：i号怪兽要求的钱  
开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。  
如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上；  
如果你当前的能力，大于等于i号怪兽的能力，你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上。   
返回通过所有的怪兽，需要花的最小钱数。  


