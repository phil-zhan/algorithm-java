
### hash表的时间复杂度
如果认为单样本的长度是可以忽略的。那么其增删改查的时间复杂度都是 O(1)  
如果认为单样本的长度是不可以忽略的。那么其增删改查的时间复杂度都是 O(单样本的平均长度)  
对象本身的hash值，基础类型是和对象的值有关。非基础类型是拿对象的内存地址来算的，与对象本身的值无关  

### 前缀树
统计有多少字符串是以某个子串开头。某个字符出现的次数等  

### 计数排序
### 基数排序

### 排序算法总结
##### 基于比较的排序
<font color="red" >目前来讲，时间复杂度O(N*logN)是极限，没有比这更好的了 </font>  
1. 冒泡排序  
2. 插入排序  
3. 选择排序  
4. 归并排序  
5. 快速排序  
6. 堆排序  
7. 希尔排序  


##### 不基于比较的排序【要求数据范围或数据本身特殊】
<font color="red" >目前来讲，时间复杂度可以做到O(N)</font>  
1. 桶排序(计数排序)  
2. 基数排序【按照个十百位来排序】  


##### 排序算法的稳定性
```text
    稳定性是指 同样大小 的样本再排序之后不会改变相对次序  

    对基础类型来说，稳定性毫无意义  

    对非基础类型来说，稳定性有重要意义  

    有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的  
    
    
    不稳定的排序：  
        选择排序：每次选择一个最小的。【5,5,5,5,5,5,3,5,5】【选了3之后，第一个5就直接跳过了好几个5到中间了】【O(N^2)】  
        快速排序：选定一个数，比其大的放在右边，比其小的放在左边。再对左右两边进行同样的操作。【分区做不到稳定】    
        堆排序：利用大小跟堆。【调整堆的时候，做不到稳定】【O(N*logN)】  
    稳定的排序：  
        冒泡排序：从左到右，依次比较两个相邻的，谁大谁往右【相等的时候，不交换，就可以实现稳定】【O(N^2)】  
        插入排序：从第二个开始，在前面有序的子数组中找到合适的位置【相等的时候，不交换，就可以实现稳定】【O(N^2)】  
        归并排序：两个有序的子数组，谁小copy谁【相等的时候，先copy左边的，就可以实现稳定】【O(N*logN)】  
        希尔排序：
```
```text
    1）不基于比较的排序，对样本数据有严格要求，不易改写  
    2）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用  
    3）基于比较的排序，时间复杂度的极限是O(N*logN)  
    4）时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的。  
    5）为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并  
```