# <font color="red">**资源限制技巧汇总**</font>

### 资源限制
1. 布隆过滤器用于集合的建立与查询，并可以节省大量空间（已讲）  
2. **一致性哈希**解决数据服务器的负载管理问题（已讲）  
3. 利用**并查集**结构做岛问题的并行计算（已讲）  
4. 哈希函数可以把数据**按照种类均匀分流**  
5. **位图**解决某一范围上数字的出现情况，并可以节省大量空间  
6. 利用**分段统计**思想、并进一步节省大量空间  
7. 利用**堆、外排序**来做多个处理单元的结果合并  



### 题目一
32位无符号整数的范围是0~4,294,967,295， 现在有一个正好包含40亿个无符号整数的文件， 可以使用最多1GB的内存，怎么找到出现次数最多的数？  
```shell
# 利用hash均匀分流
# 1GB大概可以存1亿条记录【key+value（都是int 4 字节）】，省去其他的额外开支，就算 1GB的内存能存 1000万条记录。
# 总共有 40亿。而内存每次能承载1000万。也就是需要分 400 次计算。可以在磁盘上准备400个文件。然后遍历这 40亿个数，对每个数取hash之后，再对400取模
# 得到对应的文件号，就将该数字存入对应的文件。【hash具有散列性，400个文件差不多能均分这40亿个数】。
# 遍历完成后，再对这400个文件，每个文件（1000万条）都读到内存，计算机重复次数最多的数。
# 最后就是 400 数求最大值。
```


### 题目二
32位无符号整数的范围是0~4,294,967,295， 现在有一个正好包含40亿个无符号整数的文件， 所以在整个范围中必然存在没出现过的数。  
可以使用最多1GB的内存，怎么找到所有未出现过的数？  
```shell
# 利用位图思想
# 【对文件建立位图，再将这40亿个数查询位图】
# 8位才占一个字节B。
# 准备 2^32 个bite位的数组【1G远够了】 
# 2^32 /2^3 = 2^29 B
# 2^29 /2^10 = 2^19 K
# 2^19 /2^10 = 2^9M = 512M 
# 实现bite数组，用 int 类型的数组拼。
# 填充的时候，先用 i 除以 32.看看当前位在 int 数组中的下标位置。再用 i 对 32 取模。就能得到具体的位置
# 最后再统计，没有被填充的位置。就是没有出现的数字
```
【进阶】
内存限制为 3KB，但是只用找到一个没出现过的数即可  
```shell
# 利用分段统计思想
# 3KB,大概可以分为 750个 int 类型【每个int类型 4字节】
# 找一个距离 750最近且小于 750 的 2的某次方【这里是 512】
# 原数有 40亿个，是小于2^32的。用 2^32 除以 512 。可以得到一个整数【也就是把整个范围均分成长度为512的n份】 【8388608】
# 因为我们只需要找到一个就行了，只需要分段去统计，只要哪一个小范围段没有填满【分段统计时，遍历】

# arr[0] 去统计有多少个数字落在该范围段
# arr[1] 去统计有多少个数字落在该范围段
# arr[2] 去统计有多少个数字落在该范围段
# ......
# arr[511] 去统计有多少个数字落在该范围段

# 因为总数是 2^32 是 42亿多。但是总数只有40亿。也就意味着，总会有部分范围段的数字不够 8388608 的
# 只要哪个范围段中，数字没满。也就是在这个范围段内有没出现过的数字
# 再对 该范围段的数字循环执行上面的操作【除以512，再统计，找到不满的范围段... 一次类推，不多几次就能找到没出现过的数字了】

```

【进阶】  
内存限制为 有限几个变量，但是只用找到一个没出现过的数即可  
```shell
# 还是利用上面的思想。上面是 512 分段。这里可以采用二分。将其分为左右两段去统计
```


### 题目三
有一个包含100亿个URL的大文件，假设每个URL占用64B， 请找出其中所有重复的URL  

```shell
# 利用布隆过滤器【会有失误率】
# 不能有失误率的话。采用如下的方法
# 1、利用hash的方式，将每一个url分到小文件里面去【因为同一个url，结果hash函数之后，肯定会去到同一个文件】
# 2、再去统计小文件中是否有重复的就OK了。【如果小文件还是不行，可以再分为小小文件。。。】
```
【补充】某搜索公司一天的用户搜索词汇是海量的(百亿数据量)， 请设计一种求出每天热门Top100词汇的可行办法  




### 题目四
32位无符号整数的范围是0~4294967295， 现在有40亿个无符号整数， 可以使用最多1GB的内存， 找出所有出现了两次的数。  
```shell
# 用两位来表示一个数的出现次数。1G仍然够用。【用一位来表示的时候。2^32位只需要 512M】【如果1G的内存不够，可以采用 分段 + 位图】
# 用 0、1两个bite为来表示 0 出现的次数。用 2、3两个bite为来表示 1 出现的次数。
# 如果2、3两位是 00.表示1没有出现过。
# 如果2、3两位是 01.表示1出现过1次。
# 如果2、3两位是 10.表示1出现过2次。
# 如果2、3两位是 11.表示1出现过3次或3次以上。


# 最后找出其状态是 10 的数就好
```



### 题目五
32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数。可以使用最多3K的内存，怎么找到这40亿个整数的中位数【上中位数】？  
```shell
# 利用分段统计思想
# 3KB,大概可以分为 750个 int 类型【每个int类型 4字节】
# 找一个距离 750最近且小于 750 的 2的某次方【这里是 512】
# 原数有 40亿个，是小于2^32的。用 2^32 除以 512 。可以得到一个整数【也就是把整个范围均分成长度为512的n份】 【8388608】

# arr[0] 去统计有多少个数字落在该范围段
# arr[1] 去统计有多少个数字落在该范围段
# arr[2] 去统计有多少个数字落在该范围段
# ......
# arr[511] 去统计有多少个数字落在该范围段

# 我们要找的是第 20 亿个数字。假设第一个范围段有 a 个（假设等于 1 亿个）,那么我们要找的数字绝对不在该范围段
# 将第一段的数量加上第二段的数量，假设等于 5 亿。我们要找的数也不在第二段。依次把数量往上加，谁刚好超20亿，这个上中位数一定在该区间

# 在最接近 20 亿的那个段。看前面的几个段占了多少个位置，在再当前这个段找出前 n 个缺少的【这个 n 是20亿减去前面范围占的位置数】。第 n 个就是我们要找的中位数
```



### 题目六
32位无符号整数的范围是0~4294967295，有一个10G大小的文件，每一行都装着这种类型的数字，整个文件是无序的，给你5G的内存空间，  
请你输出一个10G大小的文件，就是原文件所有数字排序的结果  
```shell
# 利用堆
# 
```