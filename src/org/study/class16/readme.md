# <font color="red">**图**</font>

### 图的传统表示方法
* 1、邻接表法
    就是利用一个hash表，key是节点。value是一个数组或链表，用于存储key对应的邻居
* 2、邻接矩阵法
    当两个点之间是有距离的时候，可以用一个矩阵来表示，横向是节点，纵向也是节点，他们相加的位置就可以用来表示其两个节点间的距离。
    【仅表示两节点间直接相连的距离】
  
* 3、经典的图表示法【Graph】

### 图的遍历

* 1、宽度优先遍历【Code01】
    类似于树的宽度优先遍历【也就是按层遍历】。但是图是可能存在回路的，除了需要一个队列之外，还要加一个set集合。避免重复遍历。
    【在入队列之前，先检查set集合，看看是否已经遍历过】
* 2、深度优先遍历【Code02】
    ①：利用递归。再加上一个Set集合。防止不要走出环路。
    ②：利用迭代来实现。不过要自己压栈
  
### 图的拓扑排序算法【Code03】
```
// 图的拓扑排序：这里的图，一定是有向无环图，否则就谈不上拓扑排序
```
* 1、最简单的解法
     用入度就够了。
     选入度为0的点为开始点。选了一个点之后，将被选点及从该店出去的边都从图上拆除，再选入度为0的点，循环往复
* 2、解法2
     统计从每个节点开始到遍历完整个图所经过的节点数。经过节点数多的点，拓扑序一定在前。经过节点数少的点，拓扑序一定在后面
     需要注意的是顶点的节点数=各分支的节点数之和。【如果各分支出现重复的点，需要重复计算】


### 最小生成树算法之Kruskal【Code04】
**这里要求的是无向图**
**解法就是利用并查集。考察所有的边，从权值小的边到权值大的边，依次考察。如果当前的边不会形成环，就要当前边，会形成环，就不要当前边**
**边的两个顶点如果在一个集合，连完之后就会成环。如果不在一个集合，连完之后，就不会成环**
* 1）总是从权值最小的边开始考虑，依次考察权值依次变大的边
* 2）当前的边要么进入最小生成树的集合，要么丢弃
* 3）如果当前的边进入最小生成树的集合中不会形成环，就要当前边
* 4）如果当前的边进入最小生成树的集合中会形成环，就不要当前边
* 5）考察完所有边之后，最小生成树的集合也得到了


### 最小生成树算法之Prim【Code05】
**从任意一个点开始，在所有可以考虑的边中，选一个最小的
【思路是从一个点开始，能看到与改点相关的所有边，从这些边中选一个最小的，**
**然后就有一个新的点进入视野,再选一个边，解锁新的点，以此往复】**
**当然，选的时候，如果边的两边的点都是被解锁过的，不予考虑**
**直到所有的点都解锁或者所有的边都考虑完**
* 1）可以从任意节点出发来寻找最小生成树
* 2）某个点加入到被选取的点中后，解锁这个点出发的所有新的边
* 3）在所有解锁的边中选最小的边，然后看看这个边会不会形成环
* 4）如果会，不要当前边，继续考察剩下解锁的边中最小的边，重复3）
* 5）如果不会，要当前边，将该边的指向点加入到被选取的点中，重复2）
* 6）当所有点都被选取，最小生成树就得到了

### Dijkstra算法【Code06】
**针对有向、无负权重、可以有环的图。给定一个出发点，从出发点出发，所能到达的点中，到各点的最短距离。返回所有最短的距离是的多少**
**考虑起点出发的边，找出最短的一条。如果该边的终点是已经出现过的点，就比较大小，新来的小就替换，否则就跳过**
**选出了一条边之后。就会再进来一个点，再考虑从起点出发，能到的点（除了前面已经找到的点）的距离，找出最短的一条。**
**循环往复**
* 1）Dijkstra算法必须指定一个源点
* 2）生成一个源点到各个点的最小距离表，一开始只有一条记录，即原点到自己的最小距离为0，源点到其他所有点的最小距离都为正无穷大
* 3）从距离表中拿出没拿过记录里的最小记录，通过这个点发出的边，更新源点到各个点的最小距离表，不断重复这一步
* 4）源点到所有的点记录如果都被拿过一遍，过程停止，最小距离表得到了

