### <font color="red">二叉树的套路判断是否是完全二叉树【Code01】</font>

### <font color="red">返回最大二叉搜索字树的头节点【Code02】</font>

### <font color="red">返回a和b的最低公共祖先【Code03】</font>
**给定一棵二叉树的头节点head，和另外两个节点a和b。 返回a和b的最低公共祖先**
* 1）汇聚点与当前节点X无关【X不是答案】
    在X的左树上已经汇聚过了。
    在X的右树上已经汇聚过了。
    在X树上，a和b没有赵全
* 2）汇聚点为当前节点【X就是答案】
    左树发现了a和b中的一个、右树发现了a和b中的另外一个
    X本身就是a和b中的一个，而左右树上发现了另外一个
    
* 3）所有情况都没中，那就是整棵树上没答案


### <font color="red">多叉树代表公司的层级结构【Code04】</font>
**多叉树代表公司的层级结构，每一个员工有一个快乐值（也就是节点的value）**
* 1）现在要给每一个员工发请柬，发到的人才会来聚会，没发到的人肯定不会来聚会
* 2）在选员工的时候，如果该员工的上级来了，他就不会来【也就是说，不能选直接上下级】【有上下级关系的不要一起邀请】
* 3）发完请柬之后，在不违反前面两个原则的情况下，希望来的人的happy值之和（节点的value）加起来最大
**解决方案**
*从下往上。列出以当前节点为头的树中，当前节点来的最大收益和当前节点不来的最大收益。*
* ① 当前节点来，其下级就都不会来，将其下级不来的最大收益`加`自己的收益就是当前节点来的收益
* ② 当前节点不来，其下级可来可不来，将其下级来的收益和不来的收益取一个最大值，就是当前节点不来的收益

### <font color="red">返回所有可能的拼接结果中，字典序最小的结果【Code05】</font>
**给定一个由字符串组成的数组strs， 必须把所有的字符串拼接起来， 返回所有可能的拼接结果中，字典序最小的结果**


### <font color="red">贪心算法求解的标准过程</font>
* 1 分析业务
* 2 根据业务逻辑找到不同的贪心策略
* 3 对于能举出反例的策略直接跳过，不能举出反例的策略要证明有效性 这往往是特别困难的，要求数学能力很高且不具有统一的技巧性

### <font color="red">贪心算法的解题套路</font>
* 1 实现一个不依靠贪心策略的解法X，可以用最暴力的尝试
* 2 脑补出贪心策略A、贪心策略B、贪心策略C...
* 3 用解法X和对数器，用实验的方式得知哪个贪心策略正确
* 4 不要去纠结贪心策略的证明 
